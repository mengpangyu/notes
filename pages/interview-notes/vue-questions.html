<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 技巧 | Learning</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/notes/logo.png">
    <meta name="description" content="PangYu 的的学习记录">
    
    <link rel="preload" href="/notes/assets/css/0.styles.a6614c03.css" as="style"><link rel="preload" href="/notes/assets/js/app.c17e7645.js" as="script"><link rel="preload" href="/notes/assets/js/2.69b563b9.js" as="script"><link rel="preload" href="/notes/assets/js/53.ced9b0a9.js" as="script"><link rel="prefetch" href="/notes/assets/js/10.1315c05f.js"><link rel="prefetch" href="/notes/assets/js/11.151a3e54.js"><link rel="prefetch" href="/notes/assets/js/12.0a2b6c42.js"><link rel="prefetch" href="/notes/assets/js/13.cbaa08a7.js"><link rel="prefetch" href="/notes/assets/js/14.018520b1.js"><link rel="prefetch" href="/notes/assets/js/15.4ff7eb20.js"><link rel="prefetch" href="/notes/assets/js/16.5c160e71.js"><link rel="prefetch" href="/notes/assets/js/17.8564c6ff.js"><link rel="prefetch" href="/notes/assets/js/18.cd5eefcf.js"><link rel="prefetch" href="/notes/assets/js/19.ab3db686.js"><link rel="prefetch" href="/notes/assets/js/20.c7662c42.js"><link rel="prefetch" href="/notes/assets/js/21.659784ac.js"><link rel="prefetch" href="/notes/assets/js/22.461a678f.js"><link rel="prefetch" href="/notes/assets/js/23.82837d2f.js"><link rel="prefetch" href="/notes/assets/js/24.4d7196c5.js"><link rel="prefetch" href="/notes/assets/js/25.cad8099d.js"><link rel="prefetch" href="/notes/assets/js/26.7b5c2815.js"><link rel="prefetch" href="/notes/assets/js/27.7cac3ed4.js"><link rel="prefetch" href="/notes/assets/js/28.e2dc67ce.js"><link rel="prefetch" href="/notes/assets/js/29.a482b6ec.js"><link rel="prefetch" href="/notes/assets/js/3.055b981a.js"><link rel="prefetch" href="/notes/assets/js/30.2d211068.js"><link rel="prefetch" href="/notes/assets/js/31.baeba016.js"><link rel="prefetch" href="/notes/assets/js/32.04090a76.js"><link rel="prefetch" href="/notes/assets/js/33.9c8a6349.js"><link rel="prefetch" href="/notes/assets/js/34.c125fbdc.js"><link rel="prefetch" href="/notes/assets/js/35.a6e0c8ae.js"><link rel="prefetch" href="/notes/assets/js/36.6e5c5323.js"><link rel="prefetch" href="/notes/assets/js/37.53d577d5.js"><link rel="prefetch" href="/notes/assets/js/38.b3a3fba4.js"><link rel="prefetch" href="/notes/assets/js/39.6f966172.js"><link rel="prefetch" href="/notes/assets/js/4.a19e0183.js"><link rel="prefetch" href="/notes/assets/js/40.2d657956.js"><link rel="prefetch" href="/notes/assets/js/41.0468e934.js"><link rel="prefetch" href="/notes/assets/js/42.e01fea8c.js"><link rel="prefetch" href="/notes/assets/js/43.f78cfeab.js"><link rel="prefetch" href="/notes/assets/js/44.496004ef.js"><link rel="prefetch" href="/notes/assets/js/45.b4d4b0fb.js"><link rel="prefetch" href="/notes/assets/js/46.6a16910c.js"><link rel="prefetch" href="/notes/assets/js/47.9d009924.js"><link rel="prefetch" href="/notes/assets/js/48.cecedafd.js"><link rel="prefetch" href="/notes/assets/js/49.d41185bd.js"><link rel="prefetch" href="/notes/assets/js/5.dc473b23.js"><link rel="prefetch" href="/notes/assets/js/50.d2ceb3f9.js"><link rel="prefetch" href="/notes/assets/js/51.12f6a9cb.js"><link rel="prefetch" href="/notes/assets/js/52.6d531a07.js"><link rel="prefetch" href="/notes/assets/js/54.667c4238.js"><link rel="prefetch" href="/notes/assets/js/55.5445a14c.js"><link rel="prefetch" href="/notes/assets/js/56.8d1d08dc.js"><link rel="prefetch" href="/notes/assets/js/57.8c33900d.js"><link rel="prefetch" href="/notes/assets/js/58.434e8d62.js"><link rel="prefetch" href="/notes/assets/js/59.353f6c23.js"><link rel="prefetch" href="/notes/assets/js/6.0ecea0fa.js"><link rel="prefetch" href="/notes/assets/js/60.2c18d540.js"><link rel="prefetch" href="/notes/assets/js/61.2e87ab3a.js"><link rel="prefetch" href="/notes/assets/js/62.1101580b.js"><link rel="prefetch" href="/notes/assets/js/63.cb034afe.js"><link rel="prefetch" href="/notes/assets/js/64.873c54f6.js"><link rel="prefetch" href="/notes/assets/js/65.95d7de1a.js"><link rel="prefetch" href="/notes/assets/js/66.af41a815.js"><link rel="prefetch" href="/notes/assets/js/67.20a09418.js"><link rel="prefetch" href="/notes/assets/js/68.b4c9f775.js"><link rel="prefetch" href="/notes/assets/js/69.5ec56233.js"><link rel="prefetch" href="/notes/assets/js/7.bb839646.js"><link rel="prefetch" href="/notes/assets/js/70.31797872.js"><link rel="prefetch" href="/notes/assets/js/71.a6d06ae4.js"><link rel="prefetch" href="/notes/assets/js/8.5f3f554c.js"><link rel="prefetch" href="/notes/assets/js/9.5cd846d7.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.a6614c03.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes/" class="home-link router-link-active"><img src="/notes/logo.png" alt="Learning" class="logo"> <span class="site-name can-hide">Learning</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/notes/pages/base-notes/js/js-this.html" class="nav-link">
  基础
</a></div><div class="nav-item"><a href="/notes/pages/project-notes/cat/wc-money.html" class="nav-link">
  项目
</a></div><div class="nav-item"><a href="/notes/pages/node-notes/node-buffer.html" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/notes/pages/linux-notes/linux-start.html" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/notes/pages/suanfa-notes/suanfa/sort.html" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/notes/pages/interview-notes/js-questions.html" class="nav-link">
  技巧
</a></div><div class="nav-item"><a href="/notes/pages/tool-notes/tool-use.html" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="/notes/pages/about-me/about-me.html" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="https://github.com/pangyujs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/notes/pages/base-notes/js/js-this.html" class="nav-link">
  基础
</a></div><div class="nav-item"><a href="/notes/pages/project-notes/cat/wc-money.html" class="nav-link">
  项目
</a></div><div class="nav-item"><a href="/notes/pages/node-notes/node-buffer.html" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/notes/pages/linux-notes/linux-start.html" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/notes/pages/suanfa-notes/suanfa/sort.html" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/notes/pages/interview-notes/js-questions.html" class="nav-link">
  技巧
</a></div><div class="nav-item"><a href="/notes/pages/tool-notes/tool-use.html" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="/notes/pages/about-me/about-me.html" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="https://github.com/pangyujs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>技巧精华</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS技巧</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue技巧</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/pages/interview-notes/vue-questions.html" aria-current="page" class="active sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#watch-和-computed-和-methods-区别是什么" class="sidebar-link">watch 和 computed 和 methods 区别是什么?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-有哪些生命周期钩子函数-分别有什么用" class="sidebar-link">Vue 有哪些生命周期钩子函数? 分别有什么用?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-如何实现组件间的通信" class="sidebar-link">Vue 如何实现组件间的通信?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-数据响应式怎么做到的" class="sidebar-link">Vue 数据响应式怎么做到的?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-set-是做什么用的" class="sidebar-link">Vue.set 是做什么用的?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vuex-你怎么用的" class="sidebar-link">Vuex 你怎么用的?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vuerouter-怎么用的" class="sidebar-link">VueRouter 怎么用的?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#hash-和-history-模式的区别" class="sidebar-link">Hash 和 History 模式的区别?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#react-和-vue-为什么要在写列表组件时写-key-作用是什么" class="sidebar-link">React 和 Vue 为什么要在写列表组件时写 key, 作用是什么</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#聊聊-redux-和-vuex-的设计思想" class="sidebar-link">聊聊 Redux 和 Vuex 的设计思想</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-中的-object-definedproperty-有什么缺陷-为什么-vue3-采用了-proxy-抛弃了-object-definedproperty" class="sidebar-link">Vue 中的 Object.definedProperty 有什么缺陷/为什么 Vue3 采用了 Proxy, 抛弃了 Object.definedProperty</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#双向绑定和-vuex-是否冲突" class="sidebar-link">双向绑定和 Vuex 是否冲突</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#在-vue-中-子组件为何不能修改父组件传递的-prop" class="sidebar-link">在 Vue 中, 子组件为何不能修改父组件传递的 Prop?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-的父组件和子组件生命周期钩子执行顺序是什么" class="sidebar-link">Vue 的父组件和子组件生命周期钩子执行顺序是什么?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-渲染大量数据时应该怎么优化" class="sidebar-link">Vue 渲染大量数据时应该怎么优化?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-如何优化首页的加载速度-首页白屏是什么问题引起的-解决方案" class="sidebar-link">Vue 如何优化首页的加载速度? 首页白屏是什么问题引起的? 解决方案?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-如何对数组方法进行变异" class="sidebar-link">Vue 如何对数组方法进行变异?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#nexttick-原理" class="sidebar-link">nextTick 原理</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#v-if-v-show-v-html-的原理是什么-它是如何封装的" class="sidebar-link">v-if, v-show, v-html 的原理是什么, 它是如何封装的?</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#对-spa-的理解-优缺点" class="sidebar-link">对 SPA 的理解, 优缺点</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#class-和-style-如何实现动态绑定" class="sidebar-link">Class 和 Style 如何实现动态绑定</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#对-keep-alive-的了解" class="sidebar-link">对 keep-alive 的了解</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#为什么-vue-里的-data-是一个函数" class="sidebar-link">为什么 Vue 里的 data 是一个函数</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#v-model-的原理" class="sidebar-link">v-model 的原理</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-组件通讯" class="sidebar-link">Vue 组件通讯</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#使用过-vue-ssr-么" class="sidebar-link">使用过 Vue SSR 么</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-router-路由模式有几种" class="sidebar-link">Vue-router 路由模式有几种</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-router-常用的-hash-和-history-原理" class="sidebar-link">Vue-router 常用的 hash 和 history 原理</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#什么是-mvvm" class="sidebar-link">什么是 MVVM</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue-如何实现双向绑定" class="sidebar-link">Vue 如何实现双向绑定</a></li><li class="sidebar-sub-header"><a href="/notes/pages/interview-notes/vue-questions.html#vue3-了解哪些" class="sidebar-link">Vue3 了解哪些</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React技巧</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Dom技巧</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Http技巧</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Css技巧</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Html技巧</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack技巧</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript技巧</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node技巧</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>开放题和刁钻题</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-技巧"><a href="#vue-技巧" class="header-anchor">#</a> Vue 技巧</h1> <h2 id="watch-和-computed-和-methods-区别是什么"><a href="#watch-和-computed-和-methods-区别是什么" class="header-anchor">#</a> watch 和 computed 和 methods 区别是什么?</h2> <ul><li><p>思路: 先翻译单词, 在阐述作用, 最后强行找不同</p></li> <li><p>要点:</p> <ul><li><p>computed 和 methods 相比</p> <ul><li><strong>computed 有缓存</strong>, 如果 computed 属性依赖没有变化, 那么 computed 属性就不会重新计算, methods 则是看到一次计算一次</li></ul></li> <li><p>watch 和 computed 相比</p> <ul><li>computed 是计算出一个属性, 而 watch 则可能是做<strong>别的事情(如上报数据)</strong></li></ul></li></ul></li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>计算属性是由 data 中的已知值，得到的一个新值。 这个新值只会根据已知值的变化而变化，其他不相关的数据的变化不会影响该新值。 计算属性不在 data 中，计算属性新值的相关已知值在 data 中。 别人变化影响我自己。 watch：监听数据的变化</p> <p>监听 data 中数据的变化 监听的数据就是 data 中的已知值 我的变化影响别人</p> <p>1.watch 擅长处理的场景：一个数据影响多个数据
2.computed 擅长处理的场景：一个数据受多个数据影响</p></div> <h2 id="vue-有哪些生命周期钩子函数-分别有什么用"><a href="#vue-有哪些生命周期钩子函数-分别有什么用" class="header-anchor">#</a> Vue 有哪些生命周期钩子函数? 分别有什么用?</h2> <ul><li>beforeCreated: 刚刚被创建, 属性计算之前</li> <li>created: 创建完成, 属性已绑定, DOM 未生成, $el 不存在</li> <li>beforeMount: 模板挂载之前</li> <li>mounted: 模板挂载之后</li> <li>beforeUpdate: 组件更新之前</li> <li>updated: 组件更新之后</li> <li>activated: 组件被激活使用</li> <li>deactivated: 组件被移出使用</li> <li>beforeDestory: 组件销毁前</li> <li>destoryed: 组件销毁后</li></ul> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>beforeCreate: 可加 loading 事件</p> <p>created: 结束 loading, 做一些初始化, 函数自执行</p> <p>mounted: 发起请求, 获取数据, 配合路由钩子做一些事</p> <p>beforeDestroy: 确认删除么?</p> <p>destroyed: 当前组件已被删除</p></div> <h2 id="vue-如何实现组件间的通信"><a href="#vue-如何实现组件间的通信" class="header-anchor">#</a> Vue 如何实现组件间的通信?</h2> <ul><li>父子组件: 使用 v-on 通过事件通信</li> <li>爷孙组件: 使用两次 v-on 通过爷爷爸爸通信, 爸爸儿子通信实现爷孙通信</li> <li>任意组件: 使用 eventBus = new Vue() 来通信, eventBus.$on 和 eventBus.$emit 是主要 API</li> <li>任意组件: 使用 Vuex 通信</li></ul> <h2 id="vue-数据响应式怎么做到的"><a href="#vue-数据响应式怎么做到的" class="header-anchor">#</a> Vue 数据响应式怎么做到的?</h2> <ul><li>使用 Object.definedProperty 把这些属性全部转为 getter/setter</li> <li>Vue 不能检测对象属性的添加或删除, 解决方案是手动调用 Vue.set 或者 this.$set</li></ul> <div class="custom-block danger"><p class="custom-block-title">危险</p> <p>如果面试官问 Vue 的双向绑定是啥?</p> <p>v-model 就是双向绑定</p></div> <p><a href="https://zhuanlan.zhihu.com/p/99487325" target="_blank" rel="noopener noreferrer">自己写的一篇博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="vue-set-是做什么用的"><a href="#vue-set-是做什么用的" class="header-anchor">#</a> Vue.set 是做什么用的?</h2> <ul><li>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对属性执行 <strong>getter/setter</strong> 转化，所以属性必须在 <strong>data 对象上存在才能让 Vue 将它转换为响应式的</strong></li> <li>对于已经创建的实例，Vue <strong>不允许动态添加根级别的响应式属性</strong></li> <li>但是可以用 Vue.set(对象,属性,值) 或 this.$set() 来设置</li></ul> <h2 id="vuex-你怎么用的"><a href="#vuex-你怎么用的" class="header-anchor">#</a> Vuex 你怎么用的?</h2> <ul><li>基本概念: Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong></li> <li>解决问题: 处理复杂的数据通信</li> <li>核心概念及作用:
<ul><li>State: <strong>唯一数据源</strong></li> <li>Getter: <strong>store 的计算属性</strong>, 用于对 state 派生出一些状态, <strong>有缓存</strong></li> <li>Mutation: <strong>相当于 methods</strong>, 对 state 里的状态加上一些外来参数的一些操作, <strong>必须是同步函数</strong></li> <li>Action: <strong>类似 Mutation</strong>, Action 提交的是 mutation，而不是直接变更状态, <strong>可以包含任意异步操作</strong></li> <li>Module: 将 store 分割成模块（module）, <strong>分解庞大的单一状态树</strong></li></ul></li></ul> <h2 id="vuerouter-怎么用的"><a href="#vuerouter-怎么用的" class="header-anchor">#</a> VueRouter 怎么用的?</h2> <ul><li>基本概念: Vue Router 是 Vue.js 官方的<strong>路由管理器</strong></li> <li>核心概念名字及作用:
<ul><li>Hash 模式: 默认模式, 利用锚点实现路由跳转</li> <li>History 模式: 就是用到一个 Html5 新加的 API, 利用 <strong>history.pushState</strong> 来改变路由但是不跳转页面, <a href="https://zhuanlan.zhihu.com/p/124939557" target="_blank" rel="noopener noreferrer">自己写的一篇路由博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, 会再刷新页面的时候请求服务器, 需要做处理</li> <li>导航守卫: 路由跳转过程中的一些钩子函数, 全局的、单个路由独享的、组件内的三种
<ul><li><strong>全局路由钩子:</strong> beforeEach(to,from, next)、beforeResolve(to,from, next)、afterEach(to,from)</li> <li><strong>独享路由钩子:</strong> beforeEnter(to,from, next)</li> <li><strong>组件内路由钩子:</strong> beforeRouteEnter(to,from, next)、beforeRouteUpdate(to,from, next)、beforeRouteLeave(to,from, next)</li></ul></li> <li>路由懒加载: 分割路由对应的不同组件, <code>import('./Foo.vue') // 返回 Promise</code></li></ul></li> <li>常用 API:
<ul><li>router-link: 组件支持用户在具有路由功能的应用中(点击)导航, 通过 <strong>to 属性指定目标地址, 默认渲染成带有正确链接的 a 标签</strong></li> <li>router-view: <strong>渲染路径匹配到的视图组件</strong>, 可内嵌自己的 router-view</li> <li>this.$router.push: 这个方法会向 <strong>history 栈添加一个新的记录,</strong> 所以, 当用户点击浏览器后退按钮时, 则回到之前的 URL</li> <li>this.$router.replace: 跟 router.push 很像, 唯一的不同就是, <strong>它不会向 history 添加新记录</strong>, 而是跟它的方法名一样 —— 替换掉当前的 history 记录</li> <li>this.$route.params: <strong>表示当前的参数</strong>即冒号后面的东西组成的对象</li></ul></li></ul> <h2 id="hash-和-history-模式的区别"><a href="#hash-和-history-模式的区别" class="header-anchor">#</a> Hash 和 History 模式的区别?</h2> <ul><li>History 设置的 URL 可以是与当前的 URL 同源的任意 URL, 而 Hash 只可以设置 # 号后的内容, 只能设置与当前 URL 同文档的 URL</li> <li>History 设置新的 URL 可以和以前一样, 也会加入新的路由栈中, 而 Hash 设置的新值必须与原来的不一样才能出发动作记录到栈中</li> <li>History 可以添加任意类型的数据到记录中, 而 Hash 只能添加短字符串</li> <li>History 可以额外设置 title 属性供后续使用</li></ul> <h2 id="react-和-vue-为什么要在写列表组件时写-key-作用是什么"><a href="#react-和-vue-为什么要在写列表组件时写-key-作用是什么" class="header-anchor">#</a> React 和 Vue 为什么要在写列表组件时写 key, 作用是什么</h2> <blockquote><p>Vue: key 的作用是为了在数据变化时强制更新组件, 以避免原地复用带来的副作用</p></blockquote> <p><strong>Vue diff 算法根据属性</strong></p> <ul><li>Vue 官网提到了如果不加 key 的话就是默认使用就地更新的策略, 即当元数据项的顺序改变时, Vue 不会移动 DOM 元素来顺应
数据项的更新, 而是就地更新每个元素, 确保他们在每个位置的索引位置正确</li> <li>就地更新是更高效的, 但是会出现副作用, 只适用于不依赖子组件或临时 DOM 状态的列表(简单列表渲染)</li> <li>Vue 官方也建议尽可能的使用 key, 除非遍历的列表非常简单, 因为 key 是识别节点的一个通用机制</li> <li>key 主要用在 Vue 的虚拟 DOM 算法, 在新旧 nodes 对比时识别 VNodes, 如果不使用 key, Vue 会最大限度的减少动态元素
并且尝试修改/复用相同类型</li> <li>key 的使用场景: 完整触发组件声明周期钩子, 触发过渡效果</li></ul> <blockquote><p>React: key 的作用是为了优化 diff 算法,</p></blockquote> <p><strong>React diff 算法自顶向下</strong></p> <ul><li>React 官网提到了在不使用 key 的情况下, 在列表后面插入节点是很容易的, 但是在列表前面插入节点就会使整个列表重新删除在创建, 这样是低效的</li> <li>所以 React 建议加上 key 属性, 这样 React 在 diff 就可以比对 key 属性来判断是否需要删除或插入</li> <li>key 最好不要使用下标, 因为当基于下标重新排序时, 组件 state 可能会遇到一些问题, 由于组件实例时基于他们的 key 来决定是否更新及复用, 如果 key
是一个下标, 那么修改顺序时会修改当前的 key, 导致非受控组件的 state(比如输入框) 可能相互篡改导致无法预期的变动</li> <li>key 也不要使用 Math.random(), 不稳定</li></ul> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>更确切的说应该是 diff 算法在你的复杂列表稳定的时候才能明显提高性能, 因为节点可以重用, 但是对于列表频繁更新的场景, 节点不能重用,
但是 diff 可以省略一部分逻辑, 因此性能也会更好, 但是两者的性能优化不在同一个维度, 一个是创建和更新节点(渲染器)的优化,
一个是 DOM diff 算法(核心引擎)的优化</p></div> <h2 id="聊聊-redux-和-vuex-的设计思想"><a href="#聊聊-redux-和-vuex-的设计思想" class="header-anchor">#</a> 聊聊 Redux 和 Vuex 的设计思想</h2> <p>相同点:</p> <ul><li>两者都是处理全局状态的工具库, 大都是 store 保存状态, dispatch(action), reducer(mutation), 生成 newState</li></ul> <p>不同点:</p> <ul><li>最大的区别处理异步的不同, Vuex 里多了异步的操作, action 之后 commit(mutation) 之前处理异步, redux 里面则通过中间件处理异步(redux-chunk,redux-saga)</li></ul> <h2 id="vue-中的-object-definedproperty-有什么缺陷-为什么-vue3-采用了-proxy-抛弃了-object-definedproperty"><a href="#vue-中的-object-definedproperty-有什么缺陷-为什么-vue3-采用了-proxy-抛弃了-object-definedproperty" class="header-anchor">#</a> Vue 中的 Object.definedProperty 有什么缺陷/为什么 Vue3 采用了 Proxy, 抛弃了 Object.definedProperty</h2> <ol><li>Object.definedProperty 无法监控到数组下标变化, 导致通过数组下标添加元素, 不能实现响应</li> <li>Object.definedProperty 只能劫持对象的属性, 从而需要对每个对象, 每个属性进行遍历, 如果属性值是对象, 还需要深度遍历,</li> <li>Proxy 可以劫持整个对象, 并返回一个新对象</li> <li>Proxy 不仅可以代理对象, 还可以代理数组, 还可以代理动态增加的属性</li> <li>Proxy 作为新标准收到浏览器厂商的重点持续性能优化, 也就是传说中的新标准的性能红利</li></ol> <h2 id="双向绑定和-vuex-是否冲突"><a href="#双向绑定和-vuex-是否冲突" class="header-anchor">#</a> 双向绑定和 Vuex 是否冲突</h2> <p>严格模式使用 Vuex 时, 当用户输入时 v-model 会视图修改属性值, 但这个修改不是在 mutation 中修改的, 所以会抛出一个
错误, 当需要在组件中使用 Vuex 的 state 时, 有两种解决方案</p> <ol><li>input 绑定 value(vuex 中的 state), 然后监听 input 的 change 或者 input 事件, 在时间回调中调用 mutation 修改
value 的值</li> <li>使用带有 setter 的双向绑定计算属性</li></ol> <h2 id="在-vue-中-子组件为何不能修改父组件传递的-prop"><a href="#在-vue-中-子组件为何不能修改父组件传递的-prop" class="header-anchor">#</a> 在 Vue 中, 子组件为何不能修改父组件传递的 Prop?</h2> <p>一个父组件下不只有一个子组件, 使用这份 Prop 数据的也不知一个子组件, 如果每个子组件都能修改 props 的话, 将会导致修改数据的
源头不止一处</p> <p>所以我们需要将修改数据的源头统一为父组件, 子组件要修改要委托父组件帮它, 从而保证父数据修改源唯一</p> <h2 id="vue-的父组件和子组件生命周期钩子执行顺序是什么"><a href="#vue-的父组件和子组件生命周期钩子执行顺序是什么" class="header-anchor">#</a> Vue 的父组件和子组件生命周期钩子执行顺序是什么?</h2> <ol><li>加载渲染过程: 父 beforeCreate =&gt; 父 created =&gt; 父 beforeMount =&gt; 子 beforeCreate =&gt; 子 created =&gt;
子 beforeMount =&gt; 子 mounted =&gt; 父 mounted</li> <li>子组件更新过程: 父 beforeUpdate =&gt; 子 beforeUpdate =&gt; 子 updated =&gt; 父 updated</li> <li>父组件更新过程: 父 beforeUpdate =&gt; 父 updated</li> <li>销毁过程: 父 beforeDestroy =&gt; 子 beforeDestroy =&gt; 子 destroyed =&gt; 父 destroyed</li></ol> <h2 id="vue-渲染大量数据时应该怎么优化"><a href="#vue-渲染大量数据时应该怎么优化" class="header-anchor">#</a> Vue 渲染大量数据时应该怎么优化?</h2> <ol><li>添加加载动画, 优化用户体验</li> <li>利用服务器渲染 SSR, 在服务端渲染组件</li> <li>避免浏览器处理大量 DOM, 比如懒加载, 异步渲染组件, 使用分页</li> <li>对于固定费响应式数据, 使用 Object.freeze 冻结</li></ol> <h2 id="vue-如何优化首页的加载速度-首页白屏是什么问题引起的-解决方案"><a href="#vue-如何优化首页的加载速度-首页白屏是什么问题引起的-解决方案" class="header-anchor">#</a> Vue 如何优化首页的加载速度? 首页白屏是什么问题引起的? 解决方案?</h2> <blockquote><p>白屏原因: 单页面应用的 html 靠 js 生成, 因为首屏需要加载很大的 js 文件, 所以当网速差的时候会产生一定程度的白屏</p></blockquote> <p>解决方案:</p> <ol><li>优化 webpack 减少模块打包体积, code-split 按需加载</li> <li>服务端渲染, 在服务端实现渲染好首页</li> <li>首页加 loading 或骨架屏</li> <li>cdn, 减少请求, gzip, 浏览器缓存</li> <li>异步渲染</li> <li>service worker</li></ol> <h2 id="vue-如何对数组方法进行变异"><a href="#vue-如何对数组方法进行变异" class="header-anchor">#</a> Vue 如何对数组方法进行变异?</h2> <p>拦截 prototype 进行方法创建</p> <h2 id="nexttick-原理"><a href="#nexttick-原理" class="header-anchor">#</a> nextTick 原理</h2> <p>在改变 state 的时候不会立即改变, 而是进入一个队列里, 然后把重复的操作去掉, 然后把最后的结果 push 进去
nextTick 后就可以看到改变的新 state, 内部使用 setImmediate, channelMessage, promise, setTimeout 实现</p> <h2 id="v-if-v-show-v-html-的原理是什么-它是如何封装的"><a href="#v-if-v-show-v-html-的原理是什么-它是如何封装的" class="header-anchor">#</a> v-if, v-show, v-html 的原理是什么, 它是如何封装的?</h2> <ul><li>v-if 会调用 addIfCondition 方法, 生成 vnode 的时候会忽略对应节点, render 就不会渲染</li> <li>v-show 会生成 vnode, render 的时候也会渲染成真实节点, 只是在 render 过程中在节点的属性修改 show 属性值, 也就是常说的 display</li> <li>v-html 通过 addProp 添加 innerHtml 属性, 归根结底设置 innerHtml 为 v-html 的值</li></ul> <h2 id="对-spa-的理解-优缺点"><a href="#对-spa-的理解-优缺点" class="header-anchor">#</a> 对 SPA 的理解, 优缺点</h2> <p>SPA 仅在 Web 页面初始化时加载相应的 HTML, JS 和 CSS, 一旦加载完成, SPA 不会因为用户的操作而进行页面重新加载或跳转
, 取而代之的利用路由记住实现 HTML 内容的变化, UI 与用户交互</p> <p>优点:</p> <ol><li>用户体验好, 快, 内容的改变不需要重新加载整个页面, 避免了不必要跳转和重复渲染</li> <li>SPA 相对服务器压力较小</li> <li>前后端职责分离, 架构清晰, 前端进行交互逻辑, 后端负责数据处理</li></ol> <p>缺点:</p> <ol><li>初次加载耗时过多, 可能出现白屏</li> <li>路由管理不能使用浏览器的前进后退管理, 所有页面切换需要自己建立栈管理</li> <li>SEO 难度较大, 所有内容都在一个页面上显示</li></ol> <h2 id="class-和-style-如何实现动态绑定"><a href="#class-和-style-如何实现动态绑定" class="header-anchor">#</a> Class 和 Style 如何实现动态绑定</h2> <p>对象语法:</p> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>{active: isActive, 'text-danger': hasError<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
data:{ isActive: true, hasError: false}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>数组语法:</p> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>[isActive ? activeClass : '', errorClass]<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
data:{ activeClass: 'active', errorClass: 'text-danger'}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="对-keep-alive-的了解"><a href="#对-keep-alive-的了解" class="header-anchor">#</a> 对 keep-alive 的了解</h2> <p>是 Vue 内置的一个组件, 可以使用被包含的组件保留状态, 避免重新渲染</p> <ul><li>一般结合路由和动态组件一起使用, 用于缓存组件</li> <li>提供 include 和 exclude 属性, 两者都支持字符串和正则表达式, include 表示只有名称匹配的组件才会被缓存,
exclude 表示任何名称匹配都不会缓存, 其中 exclude 的优先级比 include 高</li> <li>对两个钩子函数, activated 和 deactivated, 当组件被激活时, 触发钩子函数 activated, 当组件被移出时, 触发钩子函数
deactivated</li></ul> <h2 id="为什么-vue-里的-data-是一个函数"><a href="#为什么-vue-里的-data-是一个函数" class="header-anchor">#</a> 为什么 Vue 里的 data 是一个函数</h2> <p>因为组件用来复用的, JS 对象都是引用关系, 如果组件中 data 是一个对象, 那么这样作用域没有隔离, 子组件中的 data 属性
值会相互影响, 如果组件时一个 data 函数, 那么每个实例可以维护一份呗返回对象的独立拷贝, 组件间的 data 也不会相互影响,
而 new Vue 的实例是不会被复用的, 因此不存在引用对象的问题</p> <h2 id="v-model-的原理"><a href="#v-model-的原理" class="header-anchor">#</a> v-model 的原理</h2> <p>v-model 主要用在 input, textarea, select 等元素上的创建双向数据绑定, 本质上是语法糖</p> <p>v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件</p> <ul><li>text 和 textarea 元素使用 value 和 input 事件</li> <li>checkbox 和 radio 使用 checked 属性和 change 事件</li> <li>select 字段将 value 作为 prop 并将 change 作为事件</li></ul> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code>&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>something<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>something = $event.target.value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="vue-组件通讯"><a href="#vue-组件通讯" class="header-anchor">#</a> Vue 组件通讯</h2> <ol><li><p>props / $emit 父子组件通讯</p></li> <li><p>ref 与 $parent / $children 父子组件通讯</p></li></ol> <ul><li>ref: 如果普通的 DOM 元素上使用, 引用指向的是 DOM 元素, 如果用在组件上, 引用指向组件实例</li> <li>$parent / $children 访问父/子</li></ul> <ol start="3"><li>EventBus($emit/$on), 适用于父子, 隔代, 兄弟之间通讯</li></ol> <p>通过一个空的 Vue 实例作为事件中心, 用它来触发和监听事件, 从而实现任何组件的通信</p> <ol start="4"><li>$attrs / $listeners 使用与隔代组件通讯</li></ol> <ul><li>$attrs: 包含了父作用域中不被 prop 所识别的特性绑定(class和style除外), 当一个组件没有声明任何 prop 时, 这里会包含所有
父作用域绑定, 并可以通过 $attr 传入内部组件, 配合 inheritAttr 使用</li> <li>$listener: 包含了父作用域中的 v-on 事件监听器, 可通过 @$listener 传入内部组件</li></ul> <ol start="5"><li>provide / inject 适用于隔代组件通讯</li></ol> <p>祖先组件中通过 provider 来提供变量, 然后在子孙组件中通过 inject 来注入变量, provide/inject 主要解决了跨级组件间
的通信问题, 不过他的使用场景, 主要是子组件的状态, 跨级组件间建立了一种主动提供和依赖注入的关系</p> <ol start="6"><li>Vuex 适用于全局通信</li></ol> <p>是一个专为 Vue.js 应用程序开发的状态管理模式, 每一个 Vuex 应用的核心就是 store, Vuex 状态存储是响应式的, 改变 store 中状态
唯一的途径就是提交 mutation</p> <h2 id="使用过-vue-ssr-么"><a href="#使用过-vue-ssr-么" class="header-anchor">#</a> 使用过 Vue SSR 么</h2> <blockquote><p>Vue.js 是构建客户端应用程序的框架, 默认情况下浏览器输出 Vue 组件, 进行生成 DOM 和操作 DOM, 然而, 也可以将同一个组件渲染为服务端
的 HTML 字符串, 他们直接发送到浏览器, 最后将服务器渲染的页面为用户服务</p></blockquote> <p>优点:</p> <ul><li>更好的 SEO, SPA 页面通过 AJAX 获取, 而搜索引擎爬取工具并不会等待 AJAX 异步完成后再抓取页面内容, 所以 SPA 总是
抓取不到 AJAX 获取的内容的, 而 SSR 由服务器直接返回, 所以搜索引擎可以爬取</li> <li>更快的内容到达: SPA 会等待所有的 Vue 编译后才会显示页面, 而 SSR 会在服务器写好页面后直接返回</li></ul> <p>缺点:</p> <ul><li>更多的开发条件限制, 服务端渲染只支持 beforeCreate 和 created 两个钩子函数, 这回导致一些外部扩展库需要特殊处理,
才能在服务端渲染程序运行, 而且服务端渲染程序需要 Node.js 的加持</li> <li>更多的服务器负载</li></ul> <h2 id="vue-router-路由模式有几种"><a href="#vue-router-路由模式有几种" class="header-anchor">#</a> Vue-router 路由模式有几种</h2> <ol><li>hash: 使用 URL hash 来做路由, 支持所有浏览器</li> <li>history: HTML5 新增的 history 的 pushstate API</li> <li>abstract: 支持所有 JS 运行环境, 如 Node.js 服务器, 如果发现没有浏览器的 API, 那么就会强制进入这个模式</li></ol> <h2 id="vue-router-常用的-hash-和-history-原理"><a href="#vue-router-常用的-hash-和-history-原理" class="header-anchor">#</a> Vue-router 常用的 hash 和 history 原理</h2> <blockquote><p>hash 模式</p></blockquote> <p>最前的前端路由就是由 location.hash 来实现的, #后面的就表示路径的 hash 值</p> <ul><li>URL 中的 hash 值只是客户端的一种状态, 也就是说向服务端发出请求时, hash 部分会被吃掉</li> <li>hash 值的改变, 都会在浏览器的访问记录历史中增加一条记录, 因此我们能通过浏览器的嗯回退, 前进按钮控制 hash 的切换</li> <li>可以通过 a 标签, 并设置 href 属性, 当用户点击这个标签后, URL 的 hash 值会发生改变, 可以使用 JS 对 location.hash 赋值,
改变 URL 的 hash 值</li> <li>可以通过 hashChange 事件来监听 hash 值的变化, 从而对页面进行跳转</li></ul> <blockquote><p>history 模式</p></blockquote> <p>HTML5 提供了 History API 来实现 URL 的变化, 其中主要的有两个</p> <ol><li>history.pushState(): 在 history 里新增一个记录</li> <li>history.replaceState(): 替换当前的记录</li></ol> <ul><li>pushState 和 replaceState 两个 API 来实现 URL 的变化</li> <li>可以使用 pushState 来监听 url 的变化, 从而对页面进行跳转</li> <li>这两个方法不会触发 popstate 事件, 需要手动触发页面跳转</li></ul> <h2 id="什么是-mvvm"><a href="#什么是-mvvm" class="header-anchor">#</a> 什么是 MVVM</h2> <p>Model-View-ViewModel 是一个软件架构的设计模式, 基于 MVC</p> <ul><li>View 层:</li></ul> <p>视图层, HTML 和 CSS 来构建</p> <ul><li>Model 层</li></ul> <p>数据模型, 反之后端进行各种业务逻辑的数据操作</p> <ul><li>ViewModel 层</li></ul> <p>前端来维护的视图数据层, 双向绑定, 当用户操作 DOM 的时候会会直接更新视图, 开发者不需要在维护, 只需要管理数据拿给用户就好</p> <h2 id="vue-如何实现双向绑定"><a href="#vue-如何实现双向绑定" class="header-anchor">#</a> Vue 如何实现双向绑定</h2> <ol><li><p>实现一个监听器 Observer: 对数据对象进行遍历, 包括子属性对象的属性, 利用 Object.defineProperty() 对属性加上 setter 和
getter, 这样的话, 给这个对象的某个赋值, 就会触发 setter, 那么就能监听到数据变化</p></li> <li><p>实现一个解析器 Compile: 解析 Vue 模板指令, 将模板中的变量都替换成数据, 然后初始化渲染页面视图, 并将每个指令对应的 节点
绑定更新数据, 添加监听数据的订阅者, 一旦数据有变动, 收到通知, 调用更新函数进行数据更新</p></li> <li><p>实现一个 Watcher: Watcher 订阅者是 Observer 和 Compile 之间的桥梁, 主要任务是订阅 Observer 中的属性值变化的消息,
当收到属性变化的消息时, 触发解析器 Compile 中对应的更新函数</p></li> <li><p>实现一个订阅器 Dep: 订阅器从用 发布-订阅 设计模式, 用来收集订阅者 Watcher, 对监听器 Observer 和订阅者 Watcher 进行统一管理</p></li></ol> <h2 id="vue3-了解哪些"><a href="#vue3-了解哪些" class="header-anchor">#</a> Vue3 了解哪些</h2> <ol><li>监测机制的改变</li></ol> <p>Proxy 来取代 Object.defineProperty()</p> <ol start="2"><li><p>插槽改为函数的方式, 这样只会影响子组件的重新渲染, 提升了渲染的性能</p></li> <li><p>对象式的组件声明方式</p></li></ol> <p>Vue2 中的组件使用过声明的方式传入一系列的 options, 和 TS 的结合需要通过一些装饰器的方式来做, 虽然能实现功能, 但比较麻烦</p> <p>Vue3 改变了组件的声明方式, 改成了类式的写法, 这样使得和 TS 的结合变的容易</p> <p>Vue3 的源码也用 TS 来写, 使得对外暴露的 api 更容易结合 TS</p> <ol start="4"><li>其他改变</li></ol> <ul><li>支持自定义渲染器</li> <li>支持 Fragment (多个根节点) 和 Protal (在 DOM 其他部分渲染组件内容) 组件</li> <li>基于 treeShaking 优化, 提供了更多的内置功能</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新于:</span> <span class="time">4/6/2023, 10:15:39 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/notes/pages/interview-notes/js-questions.html" class="prev">
        JavaScript
      </a></span> <span class="next"><a href="/notes/pages/interview-notes/react-questions.html">
        React
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/notes/assets/js/app.c17e7645.js" defer></script><script src="/notes/assets/js/2.69b563b9.js" defer></script><script src="/notes/assets/js/53.ced9b0a9.js" defer></script>
  </body>
</html>
