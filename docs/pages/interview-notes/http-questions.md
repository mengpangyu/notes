# Http 技巧

## 说一下你知道的状态码?

- 100 continue: 服务器已经收到请求头, 并且客户端应继续发送请求体
- 101 switching protocols: 服务器已经理解了客户端请求, 并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求
- 102 processing: 表示服务器已经收到请求并且正在处理请求, 但无响应可用
- 200 ok: 请求成功
- 201 created: 已创建, 请求已经实现, 而且有一个新的资源已经依据请求的需要而创建
- 202 accepted: 已接收, 但未处理
- 203 non-authoritative information: 服务器是一个转换代理服务器
- 204 no content: 处理了请求, 无返回内容
- 205 reset content: 已经处理请求, 无返回内容, 此响应要求重置文档视图, 与 204 不同
- 301 move permanently: 资源永久重定向
- 302 found: 临时重定向
- 303 see other: 对应当前请求的响应可以在另一个 url 上被找到
- 304 not modified: 协商缓存
- 305 use proxy: 请求的资源必须通过指定代理才能访问
- 400 bad request: 请求语法错误
- 401 unauthorized: 需要权限
- 402 payment required: 支付请求, 不常用
- 403 forbidden: 服务器拒绝访问
- 404 not found: 请求页面不存在
- 405 method not allowed: 请求行中指定的请求方法不能被用于请求响应的资源
- 414 request-url to long: 请求过长
- 500 internal server error: 内部资源出错, 通用请求错误
- 501 not implemented: 服务端不支持请求的方法, 无法完成请求
- 502 bad gateway: 网关代理错误, nginx 的常见错误
- 503 service unavailable: 服务器暂时处于超负载或者正在停机维护, 无法处理请求
- 504 gateway timeout: 响应来自网关或代理, 网关或代理在等待另一台服务器的响应出现超时
- 505 HTTP version not supported: 不支持 HTTP 版本

> 1\*\* 信息, 服务端收到请求, 需要请求者继续执行操作

> 2\*\* 成功, 操作被成功接收并处理

> 3\*\* 重定向, 需要进一步完成请求

> 4\*\* 客户端错误, 请求包含语法错误或无法完成请求

> 5\*\* 服务端错误, 服务器在处理请求的过程中发生错误

## Http 缓存?

- 一个网址的旅行:

```text
1、输入一个网址：www.baidu.com
2、浏览器查找域名的IP地址
3、浏览器给web服务器发送一个http请求
4、服务器给浏览器响应一个301永久重定向：会访问“http://www.baidu.com/” 而非“http://baidu.com/”
5、浏览器跟踪重定向地址
6、服务器处理请求，并返回一个HTML响应
7、浏览器开始显示HTML
```

- DNS

> 是一个域名系统，域名是互联网上的身份标识，是不可重复的唯一标识资源，DNS 解析是互联网绝大多数应用的实际寻址方式
> 在面试中他问到我这样一个问题：DNS 解析发生在什么时候？  
> 当用户输入域名并敲回车后，系统就会调用 DNS client，寻找到用户配置或者自动分配的 DNS IP,之后就开始整个的解析过程

- 缓存

> 返回一个 HTML 文件的时候你要考虑这个文件有没有缓存过，缓存过有没有变化。
> 一般静态文件会允许浏览器对其进行缓存，有的文件可能会不需要与服务器通讯，而从缓存中直接读取。
> 缓存有什么好处？这个就比较简单了，但是也会被问到，你就说 减少相应的延迟，减少网络带宽消耗

- Expires

> 响应头，代表该资源的过期时间

- Cache-Control

> 请求/响应头，缓存控制字段，精确控制缓存策略

- If-Modified-Since

> 请求头，资源最近修改时间，由浏览器告诉服务器

- Last-Modified

> 响应头，资源最近修改时间，由服务器告诉浏览器

- Etag

> 响应头，资源标识，由服务器告诉浏览器

- If-None-Match

> 请求头，缓存资源标识，由浏览器告诉服务器

### 讲一下浏览器缓存的发展过程

1. 浏览器总是从服务器里拿文件, **没缓存, 浪费带宽, 浪费时间, 用户体验不好**
2. 加入缓存机制, 在浏览器本地把文件存下, 每次请求就从本地请求,
   - **优点:** 增加用户体验, 节省带宽
   - **缺点:** 不能拿到最新的数据
3. 加入缓存过期时间, 用 **Expires(GMT 日期)** 设置, 第一次请求服务器就返回一个文件, 后面在请求就在本地缓存中, 当时间过期后在去服务器请求
   - **优点:** 能过一段时间拿到最新的文件
   - **缺点:** 缓存过期后, 不管服务器的资源有无更新, 都会重新都服务器读取文件
4. 服务器告诉浏览器上次文件的修改时间, 响应连同 **Expires 和 Last-Modified** 返回, 当缓存过期,
   浏览器就拿 **If-Modified-Since(等于服务器上次返回的 Last-modified)** 就带到服务器上, 服务器看浏览器带来的最后一次修改时间是否与文件的修改时间相同 - **优点:** 过期后如果内容没变, 就不需要重新获取, 节省带宽, 如果文件有变化, 则返回最新的文件数据 - **缺点:** - Expires 过期控制不稳定，因为浏览器端可**以随意修改时间(用户可以修改时间)**，导致缓存使用不精准, **Last-Modified 过期时间只能精确到秒** - 只能精确到秒, 那么如果一个文件在一秒内改了很多次, 都在那在一秒内对比, 服务器就会认为最后修改时间和上一次的一样, 所以会告诉浏览器继续使用原来的缓存, 但其实文件已经改了 - 看似改了文件, 其实数据没发生变化, 但是 Last-Modified 匹配不上又会重新读取文件一次
   > 一致: 服务器告诉浏览器可以继续用原来的缓存了 **(304 未修改)**

> 不一致: 服务器读取文件返回给浏览器, 顺便把新的 Last-Modified 和 Expires 返回给浏览器

5. 增加相对时间的控制, 引入 Cache-Contorl, 浏览器除了得到 **Expires(绝对时间)**, 还会得到一个 **Cache-Control：max-age=10 秒(相对时间)**,
   10 秒的意思是在 10 秒内利用缓存在读文件, 浏览器以 Cache-Control 为准, 忽略 Expires, 如果没有 Cache-Control, 则检查 Expires

6. 解决精确到秒问题, 加入 **Etag(一般用 MD5), 文件内容变了, Etag 才变, 内容不变, Etag 不变, Etag 就相当于这个文件的唯一 ID,** 同时引入 If-None-Match,
   当再次请求服务器的时候, **If-None-Match 就是服务器上次传来的 Etag**

#### 总结

> 当浏览器第一次请求文件, 服务器会返回 Expires(绝对时间) 和 Cache-Control: max-age=10 秒(相对时间), Last-Modified(最后修改时间), Etag(标识文件的唯一 ID)

> 10 秒内再次请求直接去缓存里找

> 11 秒后请求就去服务器上, 忽略 If-Modified-Since(上次的 Last-Modified) , 对比一下 If-None-Match(上次的 Etag) , 如果有变化, 那就返回新的文件以及还是那四个响应头, 如果变化, 那就告诉浏览器还是从缓存里找

#### 还有一些问题

- 不管使用 Expires 或 Cache-Control 都**不能主动获取文件内容是否被改变**, 那么怎么解决?

众所周知不论 js、css、img 都是从 html 上在发请求获取的, 那么我们可以**不让 html 做缓存**, 每次请求 html 都是从服务器里读

每次拿到 html 里的时候在 **js 请求路径上加一个版本号**, 如果 html 再次访问 js 的版本还是和以前一样, 那么就从缓存找, 如果版本号变了, 那就重新请求

这样就解决了不能主动得知文件更新的问题, 再加上 **webpack 插件(html-webpack-plugin)的使用**, 每次会根据 hash 值生成不同名称的 html, 就可以很方便的去解决这个问题

[不错的 http 缓存 文章](https://juejin.im/post/5b3c87386fb9a04f9a5cb037#heading-1)

## GET 和 POST 的区别?

- 错解:
  - GET 在浏览器回退时是无害的, 而 POST 会再次提交请求
  - GET 在产生的 URL 地址上可以这加入收藏栏, 而 POST 不可以
  - GET 请求会被浏览器主动 cache, 而 POST 不会, 除非手动设置\
  - GET 请求只能进行 URL 编码, 而 POST 支持多种编码方式
  - GET 请求参数会被完整保留在浏览器历史记录里, 而 POST 中的参数不会被保留
  - GET 请求在 URL 中传送的参数是有长度限制的, 而 POST 没有
  - 对参数的数据类型, GET 只接受 ASCII 字符, 而 POST 没有限制
  - GET 比 POST 更不安全, 因为参数直接暴露在 URL 上, 所以不能传递敏感信息
  - GET 参数通过 URL 传递, POST 放在 Request Body 中
- 正解:
  - 就一个区别: 语义 --- GET 用于获取资源, POST 用于提交资源

:::tip 注意
HTTP 底层是 TCP/IP, 所以 GET 和 POST 都是 TCP 链接
**TCP 像汽车**, 运输数据, 为了区分数据的类别, 给每个小汽车贴标
**GET 在汽车顶上运输, POST 在汽车里运输**

运输公司就相当于不同的浏览强和服务器, 装货卸货还是有很大的代价的, 所以他们会**限制单次运输量来控制风险**
浏览器通常限制 URL 长度在 **2k 字节,** 而服务器最多处理 **64k 大小的 URL**

**GET 产生一个数据包, POST 产生两个数据包**
GET 会把请求头和数据一起发到服务器, POST 会先发请求头告诉服务器有一些数据要来, 然后再回去发数据
看起来 GET 比 POST 更高效, 但是他们的**语义不同**, 不能随便混用, 而且走的网络环境差的情况下, 验证**两次包的数完整性更好**
并不是所有的浏览器都会在 POST 请求发两次包, **Firefox 就只发一次包**
:::

> GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同

[比较好的文章](https://zhuanlan.zhihu.com/p/22536382)

## POST 和 PUT 区别

- PUT 幂等(每次相同请求返回的数据都一样), POST 非幂等
- PUT 用于修改更新旧资源, POST 用于请求新资源

> RFC 是这样解释的:

:::warning 面试

POST 和 PUT 请求之间的根本区别体现在 Request-URI 的不同含义上。
POST 请求中的 URI 标识将处理封闭实体的资源。
该资源可能是数据接受过程，某些其他协议的网关，或者是接受注释的单独实体。
相比之下，PUT 请求中的 URI 标识请求中包含的实体-用户代理知道要使用的 URI，并且服务器不得尝试将请求应用于其他资源。
如果服务器希望将该请求应用于其他 URI，则它必须发送 301（永久移动）响应；
然后，用户代理可以自行决定是否重定向请求。

:::

## Cookie 和 Session 和 LocalStorage 和 SessionStorage 区别?

- Cookie V.S. LocalStorage
  1. 主要是区别是 Cookie 会被发送到**服务器**, 而 LocalStorage **不会**
  2. Cookie 一般最大 **4k**, LocalStorage 可以用 **5mb 甚至 10mb**, 各浏览器不同
- LocalStorage V.S. SessionStorage
  1. LocalStorage 一般**不会自动过期**(除非用户自己清除), 而 SessionStorage 在**会话结束时期过期**(如关闭浏览器)
- Cookie V.S. Session
  1. Cookie **存在浏览器文件里**, Session **存在服务器的文件里**
  2. Session 是**基于 Cookie** 实现的, 具体做法就是把 SessionID 存在 Cookie 里

## session 储存在内存当中，如果有两台服务器，会出现什么问题，怎么解决?

出现问题: session 共享不了, 用户验证通不过, 带来很不好的用户体验

> 解决方案

1. 客户端 Cookie 保存

以 cookie 加密存在客户端, 优点减轻服务器的压力, 客户端在每次请求的时候带上 cookie, 这样两台服务器也能收到 session, 实现共享

缺点:

- HTTP 限制请求长度, 可能会只传输一部分 cookie
- 需要进行额外的 session 工作
- 每次访问服务器 HTTP 请求和响应头都带有以 cookie 存储的 session 信息, 增加网络负担
- 客户端存储信息, 用户可以禁用或者 cookie, 不安全

2. 服务器 session 同步

通过主-从服务器的结构, 当用户在主服务器上登录后, 通过脚本或守护进程的方式, 将 session 信息传递到各个从服务器中, 这样, 用户访问其他服务器时就可以读到 session 信息

缺点:

- 速度慢, 不稳定
- 如果主机挂了, 其他服务器就收不到 session 信息了

3. 使用集群管理 session

提供一个集群保存 session 共享信息, 其他应用统统把自己的 session 信息存放到 session 集群服务器组, 当应用系统需要 session 信息时直接去 session 集群服务器上读取, 目前大多数使用的是 memoryCatch 进行 session 存储

两种方式: Filter 方式, memcached-session-manager (MSM) 用于解决分布式 tomcat 环境下 session 共享问题的开源解决方案

4. 把 session 持久化数据库

把 session 信息存到数据库中, 其他应用可以从数据库中查出 session 信息

缺点:

- session 的并发读写在数据库中完成, 对数据库性能要求较高
- 需要额外编写 session 销毁和更改代码, 增加工作量

## HTTP1.0, HTTP1.1 和 HTTP2 的区别?

> HTTP1.0

- 无状态: 服务器不跟踪不记录请求过的状态
- 无连接: 浏览器每次请求都需要建立 tcp 连接

**无状态**

对于无状态的特性可以借助 cookie/session 机制来做身份认证和状态记录

**无连接**

无连接导致的性能状态缺陷用两种

1. 无法复用连接: 每次发送请求, 都需要一次 tcp 连接(三次握手, 四次挥手), 使得网络的利用率非常低
2. 队头阻塞: HTTP1.0 规定在前一个请求响应到达之后下一个请求才能发送, 如果前一个阻塞, 那么后面的请求也是阻塞的

> HTTP1.1

- 长连接: 新增 Connection 字段, 可以设置 keep-alive 值保持连接不断开
- 管道化: 基于上面长连接的基础, 管道化可以不等第一个请求响应继续发送后面的请求, 但响应的顺序还是按照请求的顺序返回
- 缓存处理: 新增字段 cache-control
- 断点传输

**长连接**

HTTP1.1 默认保持长连接, 数据传输完成后保持 tcp 连接不断开, 继续使用这个通道传输数据

**管道化**

基于长连接的基础, tcp 没有断开, 用的同一个通道, 虽然管道化, 可以一次发送多个请求, 但是响应仍然顺序返回, 仍然无法解决
队头阻塞问题

**缓存处理**

当浏览器请求时先看是否有缓存的资源, 如果有直接存, 直接取, 不会在发请求, 如果没有则发送

通过设置 cache-control 的 max-age 参数

**断点传输**

在上传/下载时, 如果资源过大, 将其分割为多个部分, 分别上传/下载, 如果遇到网络故障, 可以从已经上传/下载好的地方继续请求, 不用从头开始, 提高效率

在 Header 里两个参数实现, 客户端请求时对应的是 Range 服务器端响应对应的是 Content-Range

> HTTP2.0

- 二进制分帧
- 多路复用: 在共享 tcp 连接的基础上同时发送请求和响应
  - 频多路复用
  - 时分多路复用
  - 波分多路复用
  - 码分多路复用
- 头部压缩
- 服务器推送: 服务器可以额外的向客户端推送资源, 而无需客户端明确的请求

**二进制分帧**

基于二进制分帧, 在同一域名下所有访问都是同一个 tcp 连接中走, http 消息被分解为独立的帧吗乱序发送, 服务器根据标识符和首部将消息重新组装起来

:::tip 注意

1. HTTP1.0 到 HTTP1.1 的主要区别就是从无连接到长连接

2. HTTP2.0 对比 HTTP1.x 版本主要就是多路复用
   :::

## 301 永久重定向与 302 临时重定向对 SEO 有什么影响, 他们的应用场景

> 影响

- 301 便是旧地址的资源被永久删除, 搜索引擎在抓取新内容的同时也将旧的网站交换为重定向后的地址, 所有的资源都在新网址上, 所以 301 由于 302
- 302 是临时把地址改为了新地址, 但是资源还在旧地址上, 所以搜索引擎就会抓取新内容而保存旧地址

> 应用场景

301:

- 之前的网站某种原因需要移出, 然后到新网址访问
- 域名到期不想续费找到了更适合的域名
- 搜索引擎的搜索结果出现了不带 www 的域名, 而带 www 的域名却没有收录, 这时就可以使用 301 来重定向告诉搜索引擎目标地址是哪一个

302:

- 当一个网站短时间内移动到一个新的位置

## 接口如何防刷

- 总调用次数受限制, 后端做限制
- 同一客户端次数限制, 前端给接口调用加锁, 再返回结果或一定时间后解锁

## HTTP1.1 为什么不能实现多路复用

HTTP1.1 不是二进制传输, 而是通过文本传输, 由于没有流的概念, 在使用并行传输(多路复用)传递数据时, 接收端在接收到相应后, 并不能
区分多个相应分别对应的请求, 所以无法将多个相应的结果重新组装, 也就实现不了多路复用

## 简单讲解一下 http2 的多路复用

HTTP2 采用二进制传输, 取代了 HTTP1.x 的文本格式, 二进制格式解析更高效

多路复用代替了 HTTP1.x 的序列和阻塞机制, 所有的相同域名请求都通过同一个 TCP 连接并发完成, 在 HTTP1.x 中, 并发多个请求需要
多个 TCP 连接, 浏览器为了控制资源会有 6~8 个 TCP 连接都限制

HTTP2 中: 同域名下所有通信都在单个连接上完成, 消除了因多个 TCP 连接而带来的延时和内存消耗, 单个连接上可以并行交错的请求和响应, 之间互不干扰

## 说一下 HTTP 和 HTTPS

https 的 SSL 加密是在传输层实现的

### 基本概念

http: 超文本传输协议, 是互联网上应用最为广泛的一种网络协议, 是一个客户端和服务器端请求和应答的标准(TCP), 用于 WWW 服务器传输
超文本到本地浏览器的传输协议, 他可以使浏览器更加高效, 是网络传输减少

https: 是以安全为目标的 HTTP 通道, 简单讲 HTTP 的安全版, 既 HTTP 下加入 SSL 层, HTTPS 的安全基础是 SSL, 因此加密的详细内容就需要 SSL

https 协议主要作用: 建立一个信息安全通道, 确保数组的传输, 确保网站的真实性

### http 和 https 的区别

http 传输的数据是未加密的, 也就是明文的, 网景公司设置了 SSL 协议来对 http 协议传输的数据进行加密处理, 简单来说 https 协议
是由 http 和 ssl 协议建构的可进行加密传输和身份确认的网络协议, 比 http 协议的安全性更高

1. https 协议需要 ca 证书, 费用较高
2. http 是超文本传输协议, 信息是明文传输, https 贼是安全性的 ssl 加密传输协议
3. 使用不同的链接方式, 端口也不同, 一般而言, http 端口为 80, https 端口为 443
4. http 连接很简单, 是无状态的, https 协议是由 ssl + http 协议构建的加密传输, 身份确认网络协议

### https 协议的工作原理

客户端在使用 https 方式与 web 服务器通信时有以下几个步骤

1. 客户端在使用 https url 访问服务器, 则要求 web 服务器建立 ssl 连接
2. web 服务器收到客户端请求后, 会将网站的证书(包含公钥), 返回或者说传输给客户端
3. 客户端和 web 服务器端开始协商建立 ssl 链接的安全等级
4. 客户端浏览器通过双方协商一致的安全等级, 建立会话秘钥, 然后通过网站的公钥来加密会话秘钥, 并传送给网站
5. web 服务器通过自己的私钥解密出会话秘钥
6. 服务器通过会话加密与客户端之间的通信

### https 的优缺点

> 优点

- 使用 https 的可认证用户和服务器, 确保数据发送到正确的客户机和服务器
- https 协议由 ssl + http 协议构建的可进行加密传输, 身份认证的网络协议, 要比 http 安全, 可防止数据在传输过程中不被盗取,
  改变, 确保数据的完整性
- https 是现行架构下最安全的解决方案, 大幅度增加了中间人攻击的成本
- 谷歌曾在 2014 年调整搜索引擎算法, 并称采用 https 加密的网站在搜索中的排名将会更高

> 缺点

- https 握手阶段比较费时, 也会使页面加载时间延长 50%. 增加 10%~20% 的耗电
- https 缓存不如 http 高效, 会增加数据开销
- ssl 证书也需要钱, 功能越强大的证书费用越高
- ssl 需要绑定 ip, 不能在同一 ip 上绑定多个域名, ipv4 资源支持不了这种消耗

### 介绍 HTTPS 的握手过程

1. 客户端使用 HTTPS 的 url 访问 web 服务器, 要求与服务器建立 ssl 连接
2. web 服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
3. 客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥
4. 客户端利用公钥会话将秘钥加密, 并传送给服务器, 服务端利用自己的私钥解密出会话秘钥
5. 之后服务器与客户端舒春松秘钥加密传输

### HTTPS 中间人攻击

https 协议有 http + ssl 协议构成

中间人攻击过程如下

1. 服务器想客户端发送公钥
2. 攻击截取公钥, 保留在自己手上
3. 然后攻击者自己生成一个伪造的公钥, 发给客户端
4. 客户端收到伪造的公钥后, 生成加密 hash 发给服务器
5. 攻击者获取 hash 值, 用自己的私钥解密获取真秘钥
6. 同时生成假的加密 hash 值, 发给服务器
7. 服务器用私钥芥末获取假秘钥
8. 服务器用假秘钥加密传输信息

防范措施: 服务端在发送浏览器的公钥中加入 CA 证书, 浏览器可以验证 CA 证书的有效性

## 浏览器缓存读取规则

可以分成 Service Worker, MemoryCache, Disk Cache 和 Push Cache, 那请求 from memory cache 和 for disk cache
的依据是什么, 哪些数据什么时候放在 Memory Cache 和 Disk Cache 中

[深入理解浏览器缓存机制](https://www.jianshu.com/p/54cc04190252)

上面链接已经说明问题, 我来总结一下

缓存要经过这四个顺序命中后拿缓存, 否则去请求服务器

1. Service Worker: 是运行在浏览器背后的独立线程, 一般用来实现缓存功能, 使用 Service Worker 必须是 HTTPS 协议
   因为涉及到请求拦截, 所以必须保证安全, Service Worker 的缓存可以自己配置, 如何匹配缓存, 如何读取缓存, 并且缓存是持续性的
2. Memory Cache: 内存中的缓存, 短时间存在, 一旦关闭页面就会消失, 适合存取度高, 但是容量较小的
3. Disk Cache: 硬盘中的缓存, 关闭页面不会消失, 适合存取度不高, 持久化容量大的数据
4. Push Cache: 推送缓存, HTTP2 中的内容, 只在 Session 中存在, 会话结束就会释放, 缓存时间很短, chrome 5 分钟左右

## 为什么通常在发送数据埋点请求的时候使用的是 1\*1 像素的透明 gif 图片

1. 能够完成整个 HTTP 请求 + 响应
2. 触发 get 请求后不需要获取和处理数据, 服务器也不需要发送数据
3. 跨域友好
4. 执行过程无阻塞
5. 相比 XMLHttpRequest 对象发送 get 请求, 性能上更好
6. GIF 最低合法体积最小

## TCP 三次握手

:::tip 注意
介绍参数分别为什么:

1. SYN(synchronous): 建立联机
2. ACK(acknowledgement): 确认
3. PSH(push): 传送
4. FIN(finish): 结束
5. RST(reset): 重置
6. URG(urgent): 紧急
7. Seq(Sequence Number): 序列号
8. Ack(Acknowledge Number): 确认好号

:::

9. 第一次握手: 两端都 closed 关闭状态, Client 将标志位 SYN 置为 1, 随机产生一个值 seq=x, 并将该数据包发给 Server,
   Client 进入 SYN-SENT 状态, 等待 Server 确认

10. 第二次握手: Server 收到数据包后由标志位 SYN=1 得知 Client 请求建立连接, Server 将标志位 SYN 和 ACK 都置为 1,
    ack=x+1, 随机产生一个值 seq=y, 并将数据包发送给 Client 已确认连接请求, Server 进入 SYN-RCVD 状态, 此时操作系统为该
    TCP 连接分配 TCP 缓存和变量

11. Client 收到确认后, 检查 ACK 是否为 1, 如果正确则将标志位 ACK 置为 1, ack=y+1, 并且此时操作系统为该 TCP 连接分配 TCP 缓存和变量,
    并将数据包发送给 Server, Server 检查 ack 是否为 y+1, ACK
    是否为 1, 如果正确则建立成功, Client 和 Server 进入 ESTABLISHED 状态, 完成三次握手, 随后 Client 和 Server 开始传输数据

:::tip 注意
依照以下问题展开回答?

1. 请画出三次握手和四次挥手的示意图
2. 为什么连接的时候是三次握手？
3. 什么是半连接队列？
4. ISN(Initial Sequence Number)是固定的吗？
5. 三次握手过程中可以携带数据吗？
6. 如果第三次握手丢失了，客户端服务端会如何处理？
7. SYN 攻击是什么？
8. 挥手为什么需要四次？
9. 四次挥手释放连接时，等待 2MSL 的意义?
   :::

## HTTP 四次挥手

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：

> 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。

即发出连接释放报文段（FIN=1，序号 seq=u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WAIT1（终止等待 1）状态，等待服务端的确认。

> 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。

即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号 ack=u+1，序号 seq=v），服务端进入 CLOSE_WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。

> 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号 seq=w，确认号 ack=u+1），服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。

> 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入 TIME_WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，客户端才进入 CLOSED 状态。

收到一个 FIN 只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入 TIME_WAIT 是正常的，服务端通常执行被动关闭，不会进入 TIME_WAIT 状态。

## TCP 和 UDP 的区别

1. TCP 是面向连接的, UDP 是无连接的即发送数据前不需要先建立连接
2. TCP 提供可靠的服务, 也就是说, 通过 TCP 传输的数据, 无差错, 不丢失, 不重复, 且按顺序到达, UDP 尽最大努力交付, 即不保证
   可靠交付, 并且因为 TCP 可靠, 面向连接, 不会丢失数据因此适合大量数据的交换
3. TCP 面向字节流(适合银行交付, 金融交付等), UDP 面向报文, 并且网络出现拥塞不会使得其发送效率降低(因此会出现丢包, 对事实时的应用比如 ip 电话, 直播, 游戏等)
4. TCP 只能是一对一的, UDP 支持一对一, 一对多
5. TCP 的首部较大为 20 字节, 而 UDP 只有八字节
6. TCP 是面向连接的可靠性传输, 而 UDP 是不可靠的

## WebSocket 的实现和应用

### 什么是 WebSocket?

WebSocket 是 HTML5 中的协议, 支持持久连接, HTTP 协议支持持久性连接, HTTP1.0 和 HTTP1.1 都不支持持久性的连接,
HTTP1.1 中的 keep-alive, 将多个 http 请求合并为 1 个

### WebSocket 是什么样的协议, 具体有什么优点?

HTTP 的生命周期通过 Request 来界定, 也就是 Request 一个 Response, 那么在 HTTP1.0 当中, 这次 HTTP 请求就结束了,
在 HTTP1.1 中进行了改进, 有一个 `connection: Keep-alive`, 也就是说, 在一个 HTTP 连接中, 可以发送多个 Request, 接收
多个 Response, 但是必须记住, 在 HTTP 中只有一个 Request 只能对应一个 Response, 而且这个 Response 是被动的,
不能主动发起

WebSocket 是基于 HTTP 协议的, 或者说借用了 HTTP 协议来完成一部分握手, 在握手阶段与 HTTP 是相同的

一个例子:

```http request
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```

多了两个属性, Upgrade 和 Connection

告诉服务器发送的是 WebSocket

```http request
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

## HTTP 请求方式, HEAD 方式

head: 类似于 get 请求, 只不过返回的响应里没有具体的内容, 用户获取报头

options: 允许客户端查看服务器的性能, 比如服务器支持的请求方式等

## 一个图片 url 访问后直接下载怎样实现

请求的返回头里面, 用于浏览器解析的重要参数就是 OSS 的 API 文档里面的返回 HTTP 头, 就决定用户下载行为的参数

下载情况下:

1. x-oss-object-type: Normal
2. x-oss-request-id: 12jkdfgs53jwkt5436
3. x-oss-storage-class: Standard

## 说一下 web Quality (无障碍)

能够被残障人士使用的网站才能称得上一个易用的网站

使用 alt 属性, 有时候浏览器无法显示图像, 具体原因有, 用户关闭了图像显示

浏览器是语音浏览器, 如果提供了 alt 属性, 那么浏览器至少可以显示有关图像的文字

## BOM 有哪些方法?

> location

- location.href 返回或设置当前文档的的 URL
- location.search 返回 URL 中的查询字符串部分(包括?)
- location.hash 返回 URL# 后面的内容
- location.host 返回域名
- location.hostname 返回主域名
- location.pathname 返回域名后部分
- location.port 返回端口
- location.protocol 返回 URL 中的协议
- location.assign 返回当前文档的 URL
- location.replace() 设置当前文档的 URL, 并在 history 对象中的地址列表中移出这个 URL
- location.reload 重新加载页面

> history

- history.go() 前进或后退页数数
- history.back() 后退一页
- history.forward() 前进一页

> navigator

- navigator.userAgent 返回用户代理头的字符串表示
- navigator.cookieEnabled 返回浏览器是否支持(启用) Cookie

## fetch 发送两次请求的原因

fetch 发送 post 请求, 第一次发送了一个 Options 请求, 访问服务器是否支持修改的请求, 如果服务器支持, 那么在第二次中发送
真正的请求

## HTTP 常用请求头

| 协议头          | 说明                                                  |
| --------------- | ----------------------------------------------------- |
| Accept          | 可接受的响应内容类型(Content-Types)                   |
| Accept-Charset  | 可接受的字符集                                        |
| Accept-Encoding | 可接受的编码方式                                      |
| Accept-Language | 可接受的语言                                          |
| Accept-Datetime | 可接受的按照时间来表示的响应内容版本                  |
| Authorization   | 用于表示 HTTP 协议中需要认证资源的认证信息            |
| Cache-Control   | 用来指定当前请求/回复中是否使用缓存机制               |
| Connection      | 客户端(浏览器)想要优先使用的连接类型                  |
| Cookie          | Cookie 信息                                           |
| Content-Length  | 以 8 进制表示请求提的长度                             |
| Content-MD%     | 请求体的内容二进制 MD5 取散列值, 以 Base64 编码的结果 |
| Content-Type    | 请求体的 MIME 类型(用于 POST 和 PUT)                  |
| Date            | 发送日期和时间                                        |
| Expect          | 表示客户端要求服务端做出特定的行为                    |
| HOST            | 端口                                                  |
| UserAgent       | 浏览器的身份标识字符串                                |
| Upgrade         | 要求服务器升级到一个高版本协议                        |

## 强缓存、协商缓存

缓存分为两种: 强缓存和协商缓存, 根据响应 header 内容来决定

| 缓存分类 | 获取资源形式 | 状态码            | 发送请求到服务器                 |
| -------- | ------------ | ----------------- | -------------------------------- |
| 强缓存   | 从缓存中取   | 200(from cache)   | 否, 直接从缓存取                 |
| 协商缓存 | 从缓存中取   | 304(not modified) | 是, 通过服务器来告知缓存是否可用 |

:::tip 注意
强缓存相关字段有 expires, cache-control, 如果两个同时存在, cache-control 的优先级高

协商缓存相关字段 Last-Modified/if-Modified-Since, Etag/if-None-Match
:::

**普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存**

## 前端优化

降低请求量: 合并资源, 减少 HTTP 请求, minify/gzip 压缩, webP, lazyload

加快请求速度: 预解析 DNS, 减少域名数, 并行加载, CDN 分发

缓存: HTTP 协议缓存请求, 离线缓存 manifest, 离线数据缓存 localStorage

渲染: JS/CSS 优化, 加载顺序, SSR

## 浏览器输入到渲染全过程

DNS 解析：浏览器首先依次在浏览器缓存->系统缓存->路由器缓存中查找有无该域名对应 IP 地址的记录，缓存中没有则查找系统的 hosts 文件中是否有记录，如果没有则查询 DNS 服务器。

通过三次握手与目标服务器建立 TCP 连接。

浏览器构造 HTTP 请求。

将 HTTP 报文封装到一个 TCP 报文段当中，依次经过传输层、网络层、链路层、物理层将报文送达至服务器。

服务器收到请求后进行处理，然后返回一个响应报文给客户端。

浏览器得到 HTML 后构建 DOM 树，途中如果发现其他资源，会再次向服务器请求。这个过程可以通过建立 HTTP 长连接或使用 Websocket 协议代替 HTTP 协议来避免。

浏览器得到 CSS 文件后构建 CSSOM 树，再根据 DOM 树和 CSSOM 树构建渲染树，将页面呈现在显示器上。

如果在 DOM 树的构建过程中遇到 JS 脚本，则该过程会被阻塞，直到 JS 脚本下载并执行完成，除非引入 JS 脚本时设置了 defer 和 async 属性。（如果提到这点的话建议顺便看一下 defer 和 async 的区别，面试官可能会继续深入提问）

## defer 和 async 区别

- 对于 defer 加载 js 文件不会阻塞页面(异步)的渲染和资源的加载, 不过 defer 会按原本的 js 顺序执行
- 对于 async , 这个 html5 新属性, 加载完 js 文件就会执行, 不保证顺序, 异步加载

## DNS 基于哪个协议

HTTP = DNS 域名解析时间 + TCP 连接建立时间 + HTTP 交易时间

想加快 HTTP 请求速度, TCP 三次握手不会缩减, HTTP 基于 Request 和 Response, 同样也不会缩减太多

唯一的方案就是在 DNS 上面下功夫

- 采用 TCP 解析域名 = TCP 连接时间 + DNS 交易时间
- 采用 UDP 解析域名 = DNS 交易时间

DNS 同样也可用 TCP, UDP 一次一包, 为了追求速度可以用 UDP, 但请求数据量过大的话就得使用 TCP 了

## OSI 七层模型

从上到下

- 应用层: 文件传输, 常用 HTTP, snmp, FTP
- 表示层: 文件传输, 代码转换, 数据加密
- 会话层: 建立, 解除会话
- 传输层: 提供端对端的接口, TCP, UDP
- 网络层: 为数据包选择路由, IP, icmp
- 数据链路层: 传输有地址的帧
- 物理层: 二进制的数据形式在物理媒体上传输数据

## TCP/IP 的网络模型

TCP/IP 模型是一系列网络协议的总称, 这些网络协议的目的是使得计算机之间可以进行信息交换

TCP/IP 模型四层架构从上到下分别是链路层, 网络层, 传输层, 应用层

链路层的作用是负责建立电路连接, 是整个网络的物理基础, 典型的协议包括以太网, ADSL 等

网络层负责分配地址和传送二进制数据, 主要是 IP 协议

传输层负责传送文本数据, 主要是 TCP

应用层负责传送各种最终形态的数据, 是直接与用户信息打交道的层, 主要协议是 HTTP, FTP 等

## 如何理解 http 代理

就是在请求的时候不会直接发到服务器, 会经过代理去判断服务器有几个, 需要发到哪个服务器最快等等

功能:

1. 负载均衡
2. 保障安全
3. 缓存代理

via 是头部字段来表示经过了哪些代理

X-Forwarded-For 为谁转发, 记录的是请求方的 ip 地址

X-Real-IP 获取用户真实的 IP 字段, 不管经过多少代理, 都记录最初的客户端 IP

## HTTP请求为什么会请求两次

依据跨域特性, HTTP请求分为简单请求和非简单请求, 简单请求会直接请求, 非简单请求会有一个OPTIONS预检请求, 用来查看是否可以请求成功, 如果请求成功, 那么就进行正式请求
   




