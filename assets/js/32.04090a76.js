(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{506:function(t,v,_){"use strict";_.r(v);var l=_(55),i=Object(l.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"重绘与回流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重绘与回流"}},[t._v("#")]),t._v(" 重绘与回流")]),t._v(" "),_("p",[t._v("回流和重绘可以说是每一个 web 开发者都经常听到的两个词语, 但是可能有很多人不清楚这两步具体做了什么")]),t._v(" "),_("h2",{attrs:{id:"浏览器渲染过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程"}},[t._v("#")]),t._v(" 浏览器渲染过程")]),t._v(" "),_("ol",[_("li",[t._v("解析 HTML, 生成 DOM 树, 解析 CSS, 生成 CSSOM树")]),t._v(" "),_("li",[t._v("将 DOM 树和 CSSOM 树结合, 生成渲染树(Render tree)")]),t._v(" "),_("li",[t._v("Layout(回流): 根据生成的渲染树, 进行回流(layout), 得到节点的几何信息")]),t._v(" "),_("li",[t._v("Paint(重绘): 根据渲染树以及回流得到的几何信息, 得到节点的绝对像素")]),t._v(" "),_("li",[t._v("Display: 将像素发给 CPU, 显示在页面上, 而 CSS3 硬件加速的原理是新建合成层")])]),t._v(" "),_("h2",{attrs:{id:"生成渲染树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生成渲染树"}},[t._v("#")]),t._v(" 生成渲染树")]),t._v(" "),_("p",[t._v("为了构建渲染树, 浏览器主要完成了以下工作")]),t._v(" "),_("ol",[_("li",[t._v("从 DOM 树的根节点开始遍历每个可见节点")]),t._v(" "),_("li",[t._v("对于每个可见节点, 找到 CSSOM 树中的对应规则, 并应用他们")]),t._v(" "),_("li",[t._v("根据每个可见节点以及其对应的样式, 组合生成渲染树")])]),t._v(" "),_("p",[t._v("节点也分可见和不可见, 不可见的包括")]),t._v(" "),_("ol",[_("li",[t._v("不会渲染输出的节点: script meta link")]),t._v(" "),_("li",[t._v("通过 CSS 隐藏的节点: display:none;")])]),t._v(" "),_("h2",{attrs:{id:"何时发生回流重绘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#何时发生回流重绘"}},[t._v("#")]),t._v(" 何时发生回流重绘")]),t._v(" "),_("blockquote",[_("p",[t._v("回流:")])]),t._v(" "),_("ul",[_("li",[t._v("添加或删除可见的 DOM 元素")]),t._v(" "),_("li",[t._v("元素的位置发生变化")]),t._v(" "),_("li",[t._v("元素的尺寸发生变化(外边距, 内边框, 边框大小, 宽高等)")]),t._v(" "),_("li",[t._v("内容发生变化, 比如文本变化或图片替代")]),t._v(" "),_("li",[t._v("页面一开始渲染的时候")]),t._v(" "),_("li",[t._v("浏览器的窗口尺寸变化")])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),_("p",[t._v("回流一定会触发重绘, 而重绘不一定会触发回流")])]),t._v(" "),_("h2",{attrs:{id:"浏览器的优化机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的优化机制"}},[t._v("#")]),t._v(" 浏览器的优化机制")]),t._v(" "),_("p",[t._v("现代浏览器都会通过队列化修改并批量优化重排过程, 浏览器会将修改放入队列里, 知道过了一段实际或者操作达到了一个阈值\n, 才清空队列, 但是当获取布局信息操作的时候会强制队列刷新, 比如访问了一下方法")]),t._v(" "),_("ul",[_("li",[t._v("offsetTop, offsetLeft, offsetWidth, offsetHeight")]),t._v(" "),_("li",[t._v("scrollTop, scrollLeft, scrollWidth, scrollHeight")]),t._v(" "),_("li",[t._v("clientTop, clientLeft, clientWidth, clientHeight")]),t._v(" "),_("li",[t._v("getComputedStyle()")]),t._v(" "),_("li",[t._v("getBoundingClientRect")])]),t._v(" "),_("p",[t._v("在修改样式的时候, 最好避免使用上面属性, 他们会重新渲染队列, 如果使用最好将值缓存下来")]),t._v(" "),_("h2",{attrs:{id:"减少回流和重绘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减少回流和重绘"}},[t._v("#")]),t._v(" 减少回流和重绘")]),t._v(" "),_("h3",{attrs:{id:"最小化重绘和重排"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最小化重绘和重排"}},[t._v("#")]),t._v(" 最小化重绘和重排")]),t._v(" "),_("ul",[_("li",[t._v("合并多次对 DOM 样式的修改, 一次处理")]),t._v(" "),_("li",[t._v("批量修改 DOM\n"),_("ul",[_("li",[t._v("使元素脱离文档流, 脱离文档流就不会在渲染树上了\n"),_("ul",[_("li",[t._v("隐藏元素, 应用修改, 重新显示")]),t._v(" "),_("li",[t._v("使用文档判断在当前 DOM 之外构建一个子树, 再把它拷贝会文档")]),t._v(" "),_("li",[t._v("将原始元素拷贝到一个脱离文档节点中, 修改节点后, 在替换原始的元素")])])]),t._v(" "),_("li",[t._v("对其进行多次修改")]),t._v(" "),_("li",[t._v("将元素带回到文档中")])])]),t._v(" "),_("li",[t._v("避免触发同步布局事件")]),t._v(" "),_("li",[t._v("对于复杂动画, 使用绝对定位脱离文档流")]),t._v(" "),_("li",[t._v("CSS3 硬件加速")])]),t._v(" "),_("p",[_("a",{attrs:{href:"https://github.com/chenjigeng/blog/issues/4",target:"_blank",rel:"noopener noreferrer"}},[t._v("引用原文"),_("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=i.exports}}]);